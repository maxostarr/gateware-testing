import { CodeGenerator } from "gateware-ts";
import {
  Not,
  Signedness,
  HIGH,
  Switch,
  Case,
  Default,
  Constant,
  LOW,
} from "gateware-ts";
import { GWModule, Signal, Edge, If } from "gateware-ts";
import { SB_PLL40_PAD } from "gateware-ts/dist/vendor-modules/lattice-ice40/SB_PLL40_PAD";
import { ParameterString } from "gateware-ts";
import { ParamString } from "gateware-ts/dist/src/vendor-module";

// The panel is always in one of 4 possible states
enum PanelStates {
  Start,
  ShiftBit,
  ShiftBitOff,
  IncAddress,
}
// For four states, we need 2 bits of data, but we can use the calculation below
// to generalize it, so we don't need to work out the exact number of bits by hand.
// The dive by two is a quirk of TypeScript rather than something fundamental
// Basically in an enum, TS creates an object with a key for each string name,
// but also a key for the number it represents - so you can get back to the string name
// from the value
const stateBits = Math.ceil(Math.log2(Object.keys(PanelStates).length / 2));

// Some constants to control the time counting module used later
const TIME_BITS = 6;
const TIME_DELAY_BITS = 22;

class Top extends GWModule {
  // The input and output signals of the top level module relate to pins or
  // internal functionality provided by the FPGA chip itself. These pin names are
  // chosen by us, and assigned to the actual numbers in the icebreaker.pcf file
  // in the same directory
  CLK = this.input(Signal());
  BTN = this.input(Signal());
  LED3 = this.output(Signal());

  // CL is the clock we generate and provide to the panel. It goes high whenever we're
  // sending a pixels worth of data
  CL = this.output(Signal());

  // LA is the latch signal of the panel. We strobe it high when we've sent a single row
  // of pixel data (64 paralell RGB values)
  LA = this.output(Signal());

  // BL is the blanking signal. This signal is active low, and when active, prevents the
  // LEDs from being lit on the panel. We use this to make sure no weird, flickery artefacts
  // appear while we're shifting pixels out to the panel
  BL = this.output(Signal());

  // A0-A4 together make a 5 bit binary number that holds row we're currently addressing
  // A 5 bit number can hold 32 values, but this is actually a 64 row panel. This works out
  // because we're sending two rows of pixel data at a time - first row 0 and row 32, then
  // row 1 and row 33, then row 2 and 34, and so on.
  A0 = this.output(Signal());
  A1 = this.output(Signal());
  A2 = this.output(Signal());
  A3 = this.output(Signal());
  A4 = this.output(Signal());

  // Each of the 4096 individual LEDs have a red, green, and blue component which can be on or
  // off. Since we send two rows of data at a time, we have two sets of RGB signals
  R0 = this.output(Signal());
  R1 = this.output(Signal());
  G0 = this.output(Signal());
  G1 = this.output(Signal());
  B0 = this.output(Signal());
  B1 = this.output(Signal());

  // The X0 and X1 signals don't have a function (AFAIK), and we keep them low all the time
  X0 = this.output(Signal());
  X1 = this.output(Signal());

  // The rest of the signals are "internal" to the module - and are created and managed by us.
  // The blanking signal is a slightly abstracted version of the BL signal, that we can write to
  // as active high
  blanking = this.internal(Signal());

  // clk30 will represent a clock signal generated by the onboard PLL (phase locked loop) of the FPGA.
  // The standard clock of the icebreak is 12MHz, but the PLL allows us to reach higher frequencies, in
  // this case 30MHz
  clk30 = this.internal(Signal());

  // This signal represents the internal PLL having reached a stable state with the 30Mhz clock
  pllLock = this.internal(Signal());

  // The iBtn signal is an inverted version on BTN. BTN is active low on the icebreaker board, but it's
  // a little more natural to work with active high button signals
  iBtn = this.internal(Signal());

  // address is 5-bit wide concatenation of the A0-A4 signals. We can work with this signal as
  // "one number", and send each bit it's corresponding Ax signal output
  address = this.internal(Signal(5));

  // xPos is the X position of the LED we're currently addressing (where address ☝️ is the Y position)
  xPos = this.internal(Signal(6));

  // state holds the current state of the panel, as described by the enum above.
  // It explicitly begins in the "Start" state
  state = this.internal(
    Signal(stateBits, Signedness.Unsigned, PanelStates.Start),
  );

  // timeSignal is a counter that represents "continuous". We can use this signal to animate the
  // the panel over time.
  timeSignal = this.internal(Signal(TIME_BITS));

  // These two internal signals are used to generate the particular animation
  y1AndTime = this.internal(Signal(5));
  xOrTime = this.internal(Signal(5));

  // In gateware-ts, every module has to have a describe method. This method allows us to define
  // 3 main things:
  //
  // - The combinational logic of the input, output, and internal signals
  // - The synchronous logic of the input, output, and internal signals
  // - The addition and connection of any submodules
  describe() {
    // Combinational logic, sometimes called combinatorial logic, allows us to describe operations that
    // only depend on thier inputs. Every statement you express in combinational logic is an assignment
    // of an output or internal signal to some computable value.
    // This logic is NOT sequential - it happens in parallel, constantly, as long as the FPGA is powered
    this.combinationalLogic([
      // Invert the value of BTN
      this.iBtn["="](Not(this.BTN)),

      // LED3 gives us visual feedback for when the PLL is locked (though this will essentially happen
      // instantaniously in most cases)
      this.LED3["="](this.pllLock),

      // Assigning the address bits to their corresponding output
      this.A0["="](this.address.bit(0)),
      this.A1["="](this.address.bit(1)),
      this.A2["="](this.address.bit(2)),
      this.A3["="](this.address.bit(3)),
      this.A4["="](this.address.bit(4)),

      // These signals are always kept low
      this.X0["="](0),
      this.X1["="](0),

      // The two signals below are used by to decide whether to light the different components of each LED.
      // Since all 6 signals need to reference these operations, we can put them into their own signals
      // and only create the hardware once - which is then shared.
      this.y1AndTime["="](this.address["&"](this.timeSignal.slice(4, 0))),
      this.xOrTime["="](this.xPos["|"](this.timeSignal)),

      // We're blanking as long as the button is *not* pressed, or
      // the controlled blanking signal is asserted
      //
      // Note: The blanking signal is active low
      //    (i.e. the screen is blank when this signal is low)
      this.BL["="](Not(this.blanking)["|"](Not(this.BTN))),
    ]);

    // Synchronous blocks allow us to specify hardware that is reactive to an edge transition (typically a clock)
    // This allows for the use of registers - which act as a memory between clock pulses.
    // This block is active when the 30 megahertz clock goes from low to high (the positive edge)
    this.syncBlock(this.clk30, Edge.Positive, [
      // Inside, we have a switch on the state (a state machine) - which turns into a multiplexer circuit.
      Switch(this.state, [
        Case(PanelStates.Start, [
          // Ensure that all the registers are clear
          this.address["="](0),
          this.xPos["="](0),
          this.R0["="](0),
          this.R1["="](0),
          this.G0["="](0),
          this.G1["="](0),
          this.B0["="](0),
          this.B1["="](0),

          // We keep the screen blank until we're ready to show the pixels on a row
          this.blanking["="](HIGH),

          // Move to the shift bit state
          this.state["="](PanelStates.ShiftBit),
        ]),

        Case(PanelStates.ShiftBit, [
          // Ensure we're not latching bits anymore
          this.LA["="](LOW),

          // Whenever we're shifting, we should be blanking
          this.blanking["="](HIGH),

          // Munching squares (ish) in green
          this.G0["="](
            this.xOrTime
              .slice(4, 0)
              ["^"](this.y1AndTime)
              ["=="](this.xPos.slice(4, 0)),
          ),
          this.G1["="](
            this.xOrTime
              .slice(4, 0)
              ["^"](this.y1AndTime)
              ["=="](this.xPos.slice(4, 0)),
          ),

          // Clock signal for the shift register
          this.CL["="](HIGH),

          // Move into the off state to bring the clock low again and latch if we're at the end of the row
          this.state["="](PanelStates.ShiftBitOff),
        ]),

        Case(PanelStates.ShiftBitOff, [
          // Bring the pixel clock low
          this.CL["="](LOW),

          // Are we at the end of the row?
          If(this.xPos["=="](63), [
            // Latch the shifted pixels into the register
            this.LA["="](HIGH),
            // Go to the address incremement state
            this.state["="](PanelStates.IncAddress),
          ]).Else([
            // Move back to the shift state
            this.state["="](PanelStates.ShiftBit),
          ]),

          // Always increment the x position, allowing overflow at 63
          this.xPos["="](this.xPos["+"](1)),
        ]),

        Case(PanelStates.IncAddress, [
          // Incremement the address, allowing overflow
          this.address["="](this.address["+"](1)),

          // Stop blanking to allow the leds to light up
          this.blanking["="](LOW),

          // Move to the shift bit state
          this.state["="](PanelStates.ShiftBit),
        ]),

        Default([
          // If we somehow end up here, move to the start state
          this.state["="](PanelStates.Start),
        ]),
      ]),
    ]);

    // Set up a 30 Mhz clock with the PLL IP core. The class is defined below.
    const pll = new PLL();
    // We can add the PLL as a submodule of this module. Submodules expose input and output
    // signals, and we need to wire them up to this module (the parent).
    // Inputs can only have a signal "driver", but outputs can drive multiple signals in the
    // parent (or inputs of other submodules)
    this.addSubmodule(pll, "mainPll", {
      inputs: {
        clkIn: this.CLK,
      },
      outputs: {
        clkOut: [this.clk30],
        lock: [this.pllLock],
      },
    });

    // Counter/Clock scaler module, which is defined below
    const SlowCounter = createSlowCounter(TIME_BITS, TIME_DELAY_BITS);
    const timeCounter = new SlowCounter();
    this.addSubmodule(timeCounter, "timeCounter", {
      inputs: {
        clk: this.clk30,
      },
      outputs: {
        counter: [this.timeSignal],
      },
    });
  }
}

// The PLL also extends GWModule, just like the parent (the "top" module of the design)
class PLL extends GWModule {
  // These inputs and outputs can be named whatever we want - they don't have to match
  // to an FPGA pin name in the pcf file.
  clkIn = this.input(Signal());
  lock = this.output(Signal());
  clkOut = this.output(Signal());

  describe() {
    // FPGAs often include other specialised hardware (e.g RAM, i2c or SPI buses, PLLs etc)
    // In gateware-ts, these are called "Vendor Modules". They are documented in the datasheet
    // of the FPGA itself, and differ among manufacturers. Some of the ice40 specific vendor modules
    // are already described in gateware-ts, but it's simple to add your own.

    // The PLL is expressed with the SB_PLL40_PAD vendor module. Vendor modules sometimes need to
    // provide parameters as well as inputs and outputs - though for our purposes, parameters are
    // basically just glorified inputs that perform configuration.
    const pll = new SB_PLL40_PAD("pll", {
      FEEDBACK_PATH: ParamString("SIMPLE"),
      DIVR: Constant(4, 0),
      DIVF: Constant(7, 79),
      DIVQ: Constant(3, 5),
      FILTER_RANGE: Constant(3, 1),
      ENABLE_ICEGATE: Constant(1, 0),
    });

    // Vendor modules are attached to the parent in the same way as submodules, just with a different method
    // We still need to map the inputs and outputs to the signals of the parent.
    this.addVendorModule(pll, "pll", {
      inputs: {
        PACKAGEPIN: this.clkIn,
        RESETB: Constant(1, 1),
        BYPASS: Constant(1, 0),
      },
      outputs: {
        PLLOUTGLOBAL: [this.clkOut],
        LOCK: [this.lock],
      },
    });
  }
}

// We can harness the power of TypeScript by creating functions that return classes. This allows us
// to create type safe, modular, and configurable GWModules.
// The slow counter module takes a number of counter bits, as well as a number of clock divider bits,
// to create a module that runs more slowly than in parents (in reference to the clock),
// and on every slock clock edge, incremements a counter. This counter can be used by the parent module.
function createSlowCounter(counterBits: number, clockDividerBits: number) {
  return class SlowCounter extends GWModule {
    clk = this.input(Signal());
    counter = this.output(Signal(counterBits));
    divider = this.internal(
      Signal(
        clockDividerBits,
        Signedness.Unsigned,
        (1 << clockDividerBits) - 1,
      ),
    );

    describe() {
      this.syncBlock(this.clk, Edge.Positive, [
        // If we've counted all the way down to zero, we can increase the counter.
        // The counter will overflow and begin counting from zero when it reaches it's maximum value
        If(this.divider["=="](0), [this.counter["="](this.counter["+"](1))]),

        // Ever clock cycle, decrease the divider. This signal will underflow, and return to it's maximum value
        // if we subtract when it's at zero.
        this.divider["="](this.divider["-"](1)),
      ]);
    }
  };
}

// When we've defined all of our modules, we need to create a code generator.
// This we can use this code generator to either generate Verilog code from our modules,
// or to directly build the FPGA bitstream. In this case, we pass the "top" module of our
// design, as well as an options object that specifies the location of the PCF file (which
// is where we give names to the pins of the FPGA)
const cg = new CodeGenerator(new Top("top"), {
  pcfPath: "./icebreaker.pcf",
});

// Finally, we can call a method like buildBitstream (or `generateVerilogCodeForModule`)
// which will run compilation to verilog, and then pass the output through the open source
// FPGA toolchain, producing a binary bitstream file that can be loaded on to the FPGA.
cg.buildBitstream("led-panel", false);
